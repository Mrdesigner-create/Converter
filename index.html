<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>All-in-one-converter </title>

  <style>
    /* Root color variables. These let you change theme easily. */
    :root{
      --bg1:#87CEEB;   /* sky-blue gradient start */
      --bg2:#ff4b2b;   /* orange gradient end */
      --accent:#5eead4;/* mint accent color used for buttons */
      --text:#f8f5f6;  /* default text color */
      
      /* Base color for the cards (e.g., 'black') */
      --card-color-name: black; 
      
      /* üîë CONTROLS CARD TRANSPARENCY: 70% transparency (30% opaque) üîë */
      --card-opacity-pct: 70%; 
      
      /* üîë CONTROLS INNER FILE LIST TRANSPARENCY: 10% transparency (90% opaque) üîë */
      --list-opacity-pct: 80%;
    }

    /* Box sizing: makes width/height easier to reason about */
    *{ box-sizing: border-box; }

    /* Base page styles */
    body{
      margin:0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu;
      /* gradient background using variables above */
      background: linear-gradient(135deg, var(--bg1), var(--bg2));
      color: var(--text);
      transition: background 0.45s;
    }

    /* Optional full-photo background toggle; class 'bg-image' adds an image */
    body.bg-image{
      background: url('https://mrdesigner-create.github.io/photoes/Beautiful-Rose.jpg') center/cover no-repeat fixed;
    }

    /* Header spacing and text sizing */
    header{ padding: 32px 16px; text-align:center; }
    h1{ margin: 0 0 8px; font-size: clamp(24px, 3.3vw, 38px); }

    .subtitle{ opacity: .9; }

    /* Main page wrapper width and padding */
    .wrap{ max-width: 1100px; margin: 0 auto; padding: 0 16px 64px; }

    /* Responsive grid: cards flow and wrap, min-width 300px */
    .grid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap:18px; }

    /* Card style: semi-transparent dark card with rounded corners and shadow */
    .card{
      /* Use color-mix with transparency variable */
      background: color-mix(in srgb, var(--card-color-name), transparent var(--card-opacity-pct));
      border-radius: 14px;
      padding: 14px;
      box-shadow: 0 8px 24px rgba(0,0,0,.3);
      transition: transform 0.3s ease-out, box-shadow 0.3s ease-out;
      transform: translateZ(0); 
    }
    .card:hover {
      /* Subtle 3D tilt and lift when mouse hovers */
      transform: perspective(1000px) rotateX(1deg) rotateY(1deg) scale(1.02);
      box-shadow: 0 16px 40px rgba(0,0,0,.5); 
    }
    .card h3{ margin:4px 0 12px 0; }

    /* Dropzone UI element for file picking or drag/drop */
    .dropzone{
      width:100%;
      padding:12px;
      border:2px dashed rgba(255,255,255,.3);
      border-radius:12px;
      text-align:center;
      cursor:pointer;
      user-select:none;
    }
    .dropzone.dragover{ border-color: var(--accent); background: rgba(94,234,212,.08); }

    /* Native file input is hidden (we click label to open it) */
    input[type=file]{ display:none; }

    /* Primary buttons */
    button{
      cursor:pointer;
      border:none;
      padding:10px 14px;
      border-radius:12px;
      background: var(--accent);
      color:#06161a;
      font-weight:700;
      margin-top:5px;
    }
    /* Secondary (muted) button */
    button.secondary{ background:#94a3b8; color:#0b1020; }

    /* File list area inside each card */
    .file-list{
      margin-top:10px;
      font-size:13px;
      max-height:140px;
      overflow:auto;
      /* Use color-mix with list transparency variable */
      background: color-mix(in srgb, var(--card-color-name), transparent var(--list-opacity-pct));
      padding:8px;
      border-radius:8px;
    }
    .file-item{ display:flex; justify-content:space-between; padding:6px; border-bottom:1px solid rgba(255,255,255,.08); align-items:center; }
    .file-item .meta{ max-width:60%; overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }

    /* Fullscreen overlay used when user clicks 'Fullscreen' button */
    .overlay{
      position:fixed; left:0; top:0; width:100%; height:100%;
      background: rgba(0,0,0,.7);
      display:none; align-items:center; justify-content:center; z-index:9999;
    }
    .overlay.open{ display:flex; }
    .overlay .box{
      background:white; color:black;
      /* MODIFIED: Use viewport units for near-fullscreen display */
      width: 95vw; 
      height: 95vh;
      max-width: 98vw; /* Allow it to grow close to edges */
      max-height: 98vh; /* Allow it to grow close to edges */
      overflow:auto;
      padding:18px; 
      border-radius:12px; 
      box-shadow:0 0 20px rgba(0,0,0,.4);
      /* REQUESTED: Set base font size to 12px */
      font-size: 12px; 
    }
    .overlay h2{ margin-top:0; }
    
    /* üí• MODIFICATION: Increase the dropzone box height to 40mm inside the overlay üí• */
    #overlayDrop {
        min-height: 40mm; /* 40mm requested height */
        display: flex;     /* Enable flex for centering */
        align-items: center; /* Center text vertically */
        justify-content: center; /* Center text horizontally */
        padding: 12px;     /* Maintain padding for border appearance */
    }

    /* Toggle background button in top-right */
    .toggle-bg{
      position:fixed; top:10px; right:10px; padding:8px 14px;
      background:var(--accent); border-radius:8px; font-weight:700; cursor:pointer;
      z-index:10000; color:#111;
    }

    /* Preview thumbnails row */
    .preview-row{ display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; }
    .preview-card{
      width:150px; background:#fafafa; border-radius:8px; padding:8px;
      box-shadow:0 4px 12px rgba(0,0,0,.06); text-align:center; cursor:grab; color:#111;
    }
    .preview-card.dragging{ opacity:.5; }
    .preview-card img{ max-width:100%; max-height:90px; display:block; margin:0 auto 6px; }
    .preview-card canvas{ max-width:100%; height:auto; display:block; margin:0 auto 6px; }
    .preview-actions{ display:flex; gap:8px; justify-content:center; margin-top:6px; }
    
    /* New style for clickable cards with edits */
    .preview-card.individual-edit{
      border: 2px solid var(--accent);
      cursor: pointer;
    }
    
    /* Minor helper classes */
    /* MODIFIED: Changed from 13px to 12px for consistency */
    .muted{ color:#666; font-size:12px; } 
    .light-list{ margin-top:12px; }
    .list-row{
      display:flex; justify-content:space-between; padding:8px;
      border-bottom:1px solid #eee; background:#fff; border-radius:4px; margin-bottom:6px; align-items:center;
    }
    .drag-handle{ cursor:grab; padding:6px; background:#eee; border-radius:6px; margin-right:8px; }
    .controls{ display:flex; gap:12px; align-items:center; margin-top:12px; flex-wrap:wrap; }
    .control-group{ background:#f7f7f7; padding:8px; border-radius:8px; color:#111; }
    .slider{ width:160px; }
    .small{ font-size:13px; }
    .badge{ display:inline-flex; gap:6px; align-items:center; padding:4px 8px; border-radius:999px; background:rgba(94,234,212,.15); color:var(--accent); font-size:12px; font-weight:700; }
    .hint{ font-size:12px; opacity:.9; }
    .notice{ font-size:12px; margin-top:6px; }
    .success{ color:#86efac; }
    .error{ color:#fca5a5; }

    /* Footer layout rules ‚Äî keep page height and push footer to bottom */
    html, body { height: 100%; margin: 0; }
    .page-wrapper { min-height: 100%; display: flex; flex-direction: column; }
    .wrap { flex: 1; } /* allow main content to grow */
    .page-footer {
      background-color: skyblue;
      color: darkblue;
      text-align:center;
      padding:10px 10px;
      font-size:12px;
      border-top: 2px solid darkblue;
    }
    
    /* Styles for the Global Editor panel (NEW) */
    #globalEditorContainer, #individualEditorContainer {
        margin-bottom: 15px; 
        background: #fff; 
        padding: 10px; 
        border-radius: 8px; 
        color: #111; 
        display: none; /* starts hidden */
        flex-direction: column;
    }
    #globalEditorContainer.active {
        display: flex; /* shows up when active */
    }
    #globalEditorControls, #individualEditorControls {
        display: flex; 
        gap: 15px; 
        flex-wrap: wrap;
    }
    #globalEditorControls .control-group, #individualEditorControls .control-group {
        display: flex; 
        gap: 15px; 
        flex-wrap: wrap; 
        background: #f5f5f5; 
        padding: 8px; 
        border-radius: 6px; 
        flex: 1;
        min-width: 250px;
    }
  </style>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
  <script src="https://unpkg.com/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';</script>
  <script src="https://unpkg.com/docx@8.3.2/build/index.js"></script>
  <script src="https://unpkg.com/mammoth/mammoth.browser.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/pdfmake.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdfmake/0.2.7/vfs_fonts.js"></script>
</head>

<body class="bg-image">
  <div class="toggle-bg" id="toggleBgBtn">üåÖ Hide / Show Background</div>

  <header style="color: darkred;">
    <h1 h1 style="color: darkred;">All-in-one-converter</h1>
    <div class="subtitle">Combine PDFs and convert between PDF ‚Üî Word ‚Üî Excel (and Images)</div>
  </header>

  <div class="wrap">
    <div class="grid" id="converterGrid"></div>
    <p style="text-align:center;opacity:.9;margin-top:30px">‚ö° Fast client-side converter</p>
  </div>

  <div class="overlay" id="fullscreenOverlay" aria-hidden="true">
    <div class="box" role="dialog" aria-modal="true">
      <h2 id="overlayTitle"></h2>
      
      <div id="individualEditorContainer">
          <h3 id="individualEditorTitle" style="margin-top:0; margin-bottom:10px;">Edit File: <span id="currentFileName" style="font-weight:400;"></span></h3>
          <div id="individualEditorControls">
              
              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Color Filters (Images Only)</h4>
                  <label style="display:block; min-width: 170px;">
                      Brightness: <span id="indBrightnessValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="indBrightnessSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Contrast: <span id="indContrastValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="indContrastSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Saturation: <span id="indSaturationValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="indSaturationSlider" class="slider">
                  </label>
                  <button id="indResetFiltersBtn" class="secondary" style="height:36px; margin-top:5px; margin-left: 17px;">Reset Color</button>
              </div>

              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Transform (Images & PDFs)</h4>
                  <button id="indRotateBtn">Rotate 90¬∞ CW</button>
                  <button id="indFlipXBtn">Flip Horizontal</button>
                  <button id="indResetTransformBtn" class="secondary">Reset Transform</button>
              </div>
          </div>
          <div style="margin-top:10px; text-align:right;">
              <button id="indClearBtn" class="secondary">Clear Individual Edits</button>
              <button id="indDoneBtn">Done Editing</button>
          </div>
      </div>
      <div id="globalEditorContainer">
          <p style="margin-top:0; margin-bottom:10px; font-weight:700;">Global Edits (Applied to All Supported Files in the list)</p>
          <div id="globalEditorControls">
              
              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Color Filters (Images Only)</h4>
                  <label style="display:block; min-width: 170px;">
                      Brightness: <span id="brightnessValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="brightnessSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Contrast: <span id="contrastValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="contrastSlider" class="slider">
                  </label>
                  <label style="display:block; min-width: 170px;">
                      Saturation: <span id="saturationValue">0</span>%
                      <input type="range" min="-100" max="100" value="0" id="saturationSlider" class="slider">
                  </label>
                  <button id="resetFiltersBtn" class="secondary" style="height:36px; margin-top:5px; margin-left: 17px;">Reset Color</button>
              </div>

              <div class="control-group">
                  <h4 style="margin:0; width:100%; margin-bottom:5px;">Transform (Images & PDFs)</h4>
                  <button id="rotateBtn">Rotate 90¬∞ CW</button>
                  <button id="flipXBtn">Flip Horizontal</button>
                  <button id="resetTransformBtn" class="secondary">Reset Transform</button>
              </div>
          </div>
      </div>
      
      <div id="overlayControls" style="display:flex;gap:12px;align-items:center;justify-content:space-between;flex-wrap:wrap">
        <div class="muted" id="overlayCount">0 files</div>
        <div style="display:flex;gap:8px">
          <button id="submitBtn">Submit</button>
          <button class="secondary" id="downloadBtn" style="display:none">Download</button>
          <button class="secondary" id="printBtn" style="display:none">Print</button>
          <button class="secondary" id="closeBtn">Back</button>
        </div>
      </div>

      <div id="overlayDrop" class="dropzone" style="margin-top:12px;">Drop files here to add (or click). Paste (Ctrl+V) images to add.</div>
      <div id="overlayPreview" class="preview-row"></div>
      <div id="postMsg" style="margin-top:12px"></div>
    </div>
  </div>

  <footer class="page-footer">
    <div class="footer-content">
      <b><p>¬© 2025 Your Website Name. All-in-One-Converter. Made with ‚ù§Ô∏è for fast client-side conversion.</p></b>
    </div>
  </footer>

  <script>
/* ---------- core setup: prevent default browser drag/drop behavior ---------- */
['dragenter','dragover','dragleave','drop'].forEach(ev => {
  window.addEventListener(ev, (e) => {
    if (e.target && (e.target.tagName === 'INPUT' || (e.target.closest && e.target.closest('input')))) return;
    e.preventDefault();
    e.stopPropagation();
  }, { passive:false });
});

/* ---------- converter definitions (UI data model) ---------- */
const converters = [
  // 1. Combine / Merge Files (PDF/Images)
  {id:'merge', label:'1. All-in-one-merge', accept:'*'}, // MODIFIED LABEL
  // 2. PDF ‚Üí Word (.docx)
  {id:'pdf2docx', label:'2. PDF ‚Üí Word (.docx)', accept:'.pdf'},
  // 3. Word (.docx) ‚Üí PDF
  {id:'docx2pdf', label:'3. Word (.docx) ‚Üí PDF', accept:'.doc,.docx'},
  // 4. Excel (.xlsx) ‚Üí PDF
  {id:'xls2pdf', label:'4. Excel (.xlsx) ‚Üí PDF', accept:'.xls,.xlsx'},
  // 5. PDF ‚Üí Excel (.xlsx)
  {id:'pdf2xls', label:'5. PDF ‚Üí Excel (.xlsx)', accept:'.pdf'},
  // 6. Word (.docx) ‚Üí Excel (.xlsx)
  {id:'docx2xls', label:'6. Word (.docx) ‚Üí Excel (.xlsx)', accept:'.doc,.docx'},
  // 7. Excel (.xlsx) ‚Üí Word (.docx)
  {id:'xls2docx', label:'7. Excel (.xlsx) ‚Üí Word (.docx)', accept:'.xls,.xlsx'}
];

/* Insert the converter cards into the grid DOM element. */
const grid = document.getElementById('converterGrid');
converters.forEach(c=>{
  grid.insertAdjacentHTML('beforeend', `
    <section class="card" id="${c.id}">
      <h3>${c.label}</h3>
      <label class="dropzone" id="${c.id}Drop">
        Drop files here or
        <button class="secondary" data-click="choose" data-input="${c.id}Files">Choose files</button>
        <input id="${c.id}Files" type="file" accept="${c.accept}" multiple />
      </label>
      <div style="display:flex;gap:8px;margin-top:8px">
        <button class="secondary" data-clear="${c.id}">Clear</button>
        <button class="secondary" data-full="${c.id}">Fullscreen</button>
      </div>
      <div class="file-list" id="${c.id}List">No file selected</div>
    </section>
  `);
});

/* ---------- small DOM helper utilities ---------- */
/* Simple get-by-id helper */
function byId(id){ return document.getElementById(id); }

/* Escape HTML to avoid injection in lists and messages */
function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;'); }

/**
 * Format file size in bytes into human-readable format (KB, MB, GB).
 */
function formatFileSize(bytes){
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}


/* Update the visible file list for a given card. */
function setListFromInput(id){
  const input = byId(id+'Files');
  const list = byId(id+'List');
  const files = Array.from(input.files || []);
  if(!files.length){
    list.innerHTML='No file selected';
    return;
  }
  list.innerHTML = files.map((f,i)=>`<div class="file-item"><div class="meta">${i+1}. ${escapeHtml(f.name)} (${formatFileSize(f.size)})</div><div><button class="secondary" data-remove="${id}" data-index="${i}">Remove</button></div></div>`).join('');
}

/* ---------- wire up dropzone, choose and clear behavior for each converter card ---------- */
converters.forEach(c=>{
  const drop = byId(c.id+'Drop');
  const input = byId(c.id+'Files');

  /* When user clicks dropzone label, open file picker (but not when clicking the inner Choose button) */
  drop.addEventListener('click', e=>{
    if(e.target && e.target.getAttribute && e.target.getAttribute('data-click')==='choose') return;
    input.click();
  });

  /* Choose button opens native file picker ‚Äî stops propagation so label click doesn't re-open */
  const chooseBtn = drop.querySelector('button[data-click="choose"]');
  chooseBtn.addEventListener('click', (e)=> { e.stopPropagation(); byId(e.target.getAttribute('data-input')).click(); });

  /* Add nice dragover visual when file is dragged over the drop area */
  ['dragenter','dragover'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.add('dragover'); }, {passive:false}));
  ['dragleave','dragend','drop'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); e.stopPropagation(); drop.classList.remove('dragover'); }, {passive:false}));

  /* When files are dropped into the dropzone, merge dropped items into existing input.files */
  drop.addEventListener('drop', e=>{
    const dt = new DataTransfer();
    Array.from(input.files || []).forEach(f => dt.items.add(f)); // keep existing files
    Array.from(e.dataTransfer.files || []).forEach(f => {
      dt.items.add(f);
    });
    input.files = dt.files;
    setListFromInput(c.id);
  });

  /* When native input changes (user picked files), update list display */
  input.addEventListener('change', ()=> setListFromInput(c.id));

  /* Clear button empties the file input and updates UI */
  const clearBtn = document.querySelector(`[data-clear="${c.id}"]`);
  if(clearBtn) clearBtn.addEventListener('click', ()=>{ input.value=''; setListFromInput(c.id); });
});

/* Remove single file from input when clicking 'Remove' in file-list */
document.addEventListener('click', (e)=>{
  const rem = e.target.closest('button[data-remove]');
  if(!rem) return;
  const idBase = rem.getAttribute('data-remove');
  const index = Number(rem.getAttribute('data-index'));
  const input = byId(idBase+'Files');
  const dt = new DataTransfer();
  Array.from(input.files || []).forEach((f,i)=>{ if(i!==index) dt.items.add(f); });
  input.files = dt.files;
  setListFromInput(idBase);
});


/* ---------- overlay & preview state and helpers ---------- */
/* Cached DOM for overlay controls */
const overlay = byId('fullscreenOverlay'), overlayTitle = byId('overlayTitle'), overlayCount = byId('overlayCount');
const overlayDrop = byId('overlayDrop'), overlayPreview = byId('overlayPreview');
const submitBtn = byId('submitBtn'), downloadBtn = byId('downloadBtn'), printBtn = byId('printBtn'), closeBtn = byId('closeBtn'), postMsg = byId('postMsg');
const globalEditorContainer = byId('globalEditorContainer');
const individualEditorContainer = byId('individualEditorContainer'); // NEW
const overlayBox = document.querySelector('.overlay .box');

let activeSection = null;
let lastResult = null; // store last conversion result { blob, filename, mime }

/* NEW GLOBAL STATE FOR IMAGE/PDF EDITS */
let globalMergeSettings = {
    rotation: 0, // 0, 90, 180, 270...
    flipX: 1,    // 1 (normal) or -1 (flipped)
    brightness: 0,
    contrast: 0,
    saturation: 0,
};

// NEW: Per-file settings storage
let individualFileSettings = {}; // { fileName: { rotation, flipX, brightness, contrast, saturation } }
let currentEditingFile = null; // Reference to the file currently being edited

let imageCache = {}; // Cache for loaded Image objects to avoid re-loading

/* openFullscreen: show overlay for chosen converter section */
function openFullscreen(sectionId){
  activeSection = sectionId;
  overlayTitle.textContent = document.querySelector('#'+sectionId+' h3').textContent;
  overlayCount.textContent = (byId(sectionId+'Files').files.length || 0) + ' files';
  lastResult = null;
  downloadBtn.style.display='none';
  printBtn.style.display='none';
  postMsg.innerHTML='';
  closeBtn.textContent = 'Back';
  closeBtn.onclick = closeFullscreen; // Restore default handler
  
  // Show/Hide Global Editor Controls, ensure individual is hidden
  individualEditorContainer.style.display = 'none'; // Hide individual editor
  overlayDrop.style.display = 'block'; // Ensure dropzone is visible
  overlayPreview.style.display = 'flex'; // Ensure preview is visible
  
  if (sectionId === 'merge') {
      globalEditorContainer.classList.add('active');
      wireGlobalControls(); 
      resetGlobalControls(false); // Reset settings but don't force a redraw yet
  } else {
      globalEditorContainer.classList.remove('active');
      resetGlobalControls(false); // Reset state when leaving merge section
  }

  renderOverlayPreviewFromInput(); // build preview thumbnails / list
  overlay.classList.add('open'); overlay.setAttribute('aria-hidden','false');
}

/* wire fullscreen button for each card */
document.querySelectorAll('[data-full]').forEach(btn=> btn.addEventListener('click', ()=> openFullscreen(btn.getAttribute('data-full')) ));

/* close overlay */
function closeFullscreen(){ 
  overlay.classList.remove('open'); 
  overlay.setAttribute('aria-hidden','true'); 
  activeSection=null; 
  globalEditorContainer.classList.remove('active');
  individualEditorContainer.style.display = 'none'; // Hide individual editor
  // Clear image cache and reset controls on close
  imageCache = {}; 
  resetGlobalControls(false);
}
closeBtn.addEventListener('click', closeFullscreen);

/* overlay drop handlers: allow adding files into overlay as well */
['dragenter','dragover'].forEach(ev=> overlayDrop.addEventListener(ev, e=>{ e.preventDefault(); overlayDrop.classList.add('dragover'); }, {passive:false}));
['dragleave','dragend','drop'].forEach(ev=> overlayDrop.addEventListener(ev, e=>{ e.preventDefault(); overlayDrop.classList.remove('dragover'); }, {passive:false}));

/* click overlay drop to open the file input for active section */
overlayDrop.addEventListener('click', ()=> { if(!activeSection) return; byId(activeSection+'Files').click(); });

/* drop on overlay: merge dropped files into current active section input */
overlayDrop.addEventListener('drop', e=>{
  e.preventDefault();
  overlayDrop.classList.remove('dragover');
  if(!activeSection) return;
  const input = byId(activeSection+'Files');
  const dt = new DataTransfer();
  Array.from(input.files || []).forEach(f=> dt.items.add(f));
  Array.from(e.dataTransfer.files || []).forEach(f=>{
    dt.items.add(f);
  });
  input.files = dt.files; setListFromInput(activeSection); renderOverlayPreviewFromInput();
  overlayCount.textContent = (input.files.length || 0) + ' files';
});

/* paste event: allow Ctrl+V of images into overlay (clipboard images) */
document.addEventListener('paste', (e)=>{
  if(!activeSection || !overlay.classList.contains('open')) return;
  if(activeSection !== 'merge') return; // Only allow paste for merge section

  const items = Array.from(e.clipboardData?.items || []);
  const fileItems = items.filter(it => it.kind === 'file');
  if(!fileItems.length) return;

  const input = byId(activeSection+'Files');
  const dt = new DataTransfer();
  Array.from(input.files || []).forEach(f=> dt.items.add(f));
  fileItems.forEach(it => { const file = it.getAsFile(); if(file) dt.items.add(file); });

  input.files = dt.files; setListFromInput(activeSection); renderOverlayPreviewFromInput(); overlayCount.textContent = (input.files.length || 0) + ' files';
});

/* when any converter input changes, update overlay preview if it's the active section */
converters.forEach(c=> byId(c.id+'Files').addEventListener('change', ()=>{ setListFromInput(c.id); if(activeSection === c.id) renderOverlayPreviewFromInput(); }));


/* ---------- SETTINGS HELPER (NEW/UPDATED) ---------- */

/**
 * Retrieves the effective settings for a given file, prioritizing individual edits.
 * @param {File} file The file object.
 * @returns {object} The combined settings object.
 */
function getSettings(file) {
    const defaults = { rotation: 0, flipX: 1, brightness: 0, contrast: 0, saturation: 0 };
    
    // 1. Individual Settings (highest priority)
    const individual = individualFileSettings[file.name];
    if (individual) {
        // Check if any individual edit has been made (by comparing to defaults)
        const hasIndividualEdit = Object.keys(defaults).some(k => individual[k] !== undefined && individual[k] !== defaults[k]);
        
        if (hasIndividualEdit) {
            return { ...defaults, ...individual };
        }
    }

    // 2. Global Settings (fallback for files without explicit individual edits)
    if (activeSection === 'merge') {
        return { ...defaults, ...globalMergeSettings };
    }
    
    // 3. Default (no edits)
    return defaults;
}


/* ---------- GLOBAL IMAGE EDITOR IMPLEMENTATION (NEW/UPDATED) ---------- */

/**
 * applyColorFilter: Canvas-based pixel manipulation for Brightness, Contrast, and Saturation.
 * This function is used by the main thread (for small previews) and by the Web Worker (for full-size processing).
 */
function applyColorFilter(canvas, brightness, contrast, saturation) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const b = brightness / 100 * 255;
    const c = (contrast + 100) / 100;
    const S = (saturation / 100) + 1;
    const L_R = 0.2126; const L_G = 0.7152; const L_B = 0.0722;

    for (let i = 0; i < data.length; i += 4) {
        let r = data[i], g = data[i + 1], b_val = data[i + 2];
        r = Math.max(0, Math.min(255, ((r + b - 128) * c) + 128));
        g = Math.max(0, Math.min(255, ((g + b - 128) * c) + 128));
        b_val = Math.max(0, Math.min(255, ((b_val + b - 128) * c) + 128));

        if (S !== 1) {
            const avg = r * L_R + g * L_G + b_val * L_B;
            r = avg * (1 - S) + r * S;
            g = avg * (1 - S) + g * S;
            b_val = avg * (1 - S) + b_val * S;
            
            // Correction for a potential typo in the saturation calculation in the original snippet:
            r = avg * (1 - S) + r * S;
            g = avg * (1 - S) + g * S;
            b_val = avg * (1 - S) + b_val * S;
        }

        data[i] = Math.max(0, Math.min(255, r));
        data[i + 1] = Math.max(0, Math.min(255, g));
        data[i + 2] = Math.max(0, Math.min(255, b_val));
    }
    ctx.putImageData(imageData, 0, 0);
}

/**
 * Loads an image onto a canvas, applies transformations, and color filters
 * based on the provided settings object. (Used for Images and Image Thumbnails)
 */
function applyImageEditsToCanvas(canvas, file, settings) {
    return new Promise(async (resolve, reject) => {
        // Use cached image if available
        let img = imageCache[file.name];
        if (!img) {
            img = new Image();
            const imgUrl = URL.createObjectURL(file);
            img.onload = () => {
                URL.revokeObjectURL(imgUrl);
                imageCache[file.name] = img; // Cache for next use
                processImage();
                resolve(img);
            };
            img.onerror = (e) => {
                URL.revokeObjectURL(imgUrl);
                reject(new Error("Image load failed for editing."));
            };
            img.src = imgUrl;
        } else {
            // Wait for image load if it was not done yet (should not happen if cached)
            if(!img.complete) {
                img.onload = processImage;
            } else {
                processImage();
            }
            resolve(img);
        }

        function processImage() {
            const ctx = canvas.getContext('2d');
            const w_orig = img.naturalWidth;
            const h_orig = img.naturalHeight;
            const { rotation, flipX, brightness, contrast, saturation } = settings;

            // 1. Calculate Canvas Dimensions based on Rotation
            const isRotated = (rotation % 180) !== 0; // 90 or 270 degrees
            let w = w_orig;
            let h = h_orig;
            
            // For thumbnails, keep a max size, but for full processing (in worker), use original size
            const isThumbnail = canvas.width < 500 && canvas.height < 500;
            
            if (!isThumbnail) {
                // If not a thumbnail, use original dimensions
                w = w_orig;
                h = h_orig;
            } else {
                // For thumbnails, keep aspect ratio but max width/height
                const maxDim = 200;
                const ratio = Math.min(maxDim / w_orig, maxDim / h_orig, 1);
                w = w_orig * ratio;
                h = h_orig * ratio;
            }
            
            // Adjust dimensions for rotation
            if(isRotated) {
                canvas.width = h;
                canvas.height = w;
            } else {
                canvas.width = w;
                canvas.height = h;
            }

            // 2. Apply Transformations
            ctx.save();
            // Center the canvas for rotation/flip
            ctx.translate(canvas.width / 2, canvas.height / 2);

            // Apply flip
            ctx.scale(flipX, 1);

            // Apply rotation
            ctx.rotate(rotation * Math.PI / 180);
            
            // Draw the image
            let dx = 0, dy = 0, dw = w, dh = h;

            if (isRotated) {
                // Correct drawing position after rotation
                dx = -dh / 2; dy = -dw / 2; dw = dh; dh = dw; 
                ctx.drawImage(img, dx, dy, dw, dh);
            } else {
                // Standard drawing position
                ctx.drawImage(img, -dw / 2, -dh / 2, dw, dh);
            }
            
            ctx.restore();

            // 3. Apply Color Filters (only if applied globally/individually)
            if(brightness !== 0 || contrast !== 0 || saturation !== 0) {
                // Re-draw to an intermediate canvas to capture the transform before applying filters
                // For performance, we skip this intermediate step in the worker, but for the main thread preview,
                // we run it directly on the canvas which is fine for small thumbnails.
                // In the worker, the canvas size is set to the final dimensions (full size).
                applyColorFilter(canvas, brightness, contrast, saturation);
            }
        }
    });
}

// Reset the global editor controls to default state
function resetGlobalControls(redraw = true) {
    globalMergeSettings.rotation = 0;
    globalMergeSettings.flipX = 1;
    globalMergeSettings.brightness = 0;
    globalMergeSettings.contrast = 0;
    globalMergeSettings.saturation = 0;
    const brightnessSlider = byId('brightnessSlider');
    const contrastSlider = byId('contrastSlider');
    const saturationSlider = byId('saturationSlider');
    if (brightnessSlider) brightnessSlider.value = 0;
    if (contrastSlider) contrastSlider.value = 0;
    if (saturationSlider) saturationSlider.value = 0;
    if (byId('brightnessValue')) byId('brightnessValue').textContent = 0;
    if (byId('contrastValue')) byId('contrastValue').textContent = 0;
    if (byId('saturationValue')) byId('saturationValue').textContent = 0;
    if (redraw) renderOverlayPreviewFromInput();
}
let controlsWired = false;
function wireGlobalControls() {
    if (controlsWired) return;
    const brightnessSlider = byId('brightnessSlider');
    const contrastSlider = byId('contrastSlider');
    const saturationSlider = byId('saturationSlider');
    const brightnessValueSpan = byId('brightnessValue');
    const contrastValueSpan = byId('contrastValue');
    const saturationValueSpan = byId('saturationValue');
    const rotateBtn = byId('rotateBtn');
    const flipXBtn = byId('flipXBtn');
    const resetFiltersBtn = byId('resetFiltersBtn');
    const resetTransformBtn = byId('resetTransformBtn');
    const updateSettingsAndRedraw = () => {
        globalMergeSettings.brightness = Number(brightnessSlider.value);
        globalMergeSettings.contrast = Number(contrastSlider.value);
        globalMergeSettings.saturation = Number(saturationSlider.value);
        brightnessValueSpan.textContent = globalMergeSettings.brightness;
        contrastValueSpan.textContent = globalMergeSettings.contrast;
        saturationValueSpan.textContent = globalMergeSettings.saturation;
        renderOverlayPreviewFromInput();
    };
    brightnessSlider.addEventListener('input', updateSettingsAndRedraw);
    contrastSlider.addEventListener('input', updateSettingsAndRedraw);
    saturationSlider.addEventListener('input', updateSettingsAndRedraw);
    resetFiltersBtn.addEventListener('click', () => {
        globalMergeSettings.brightness = 0;
        globalMergeSettings.contrast = 0;
        globalMergeSettings.saturation = 0;
        brightnessSlider.value = 0;
        contrastSlider.value = 0;
        saturationSlider.value = 0;
        updateSettingsAndRedraw();
    });
    rotateBtn.addEventListener('click', () => {
        globalMergeSettings.rotation = (globalMergeSettings.rotation + 90) % 360;
        renderOverlayPreviewFromInput();
    });
    flipXBtn.addEventListener('click', () => {
        globalMergeSettings.flipX *= -1;
        renderOverlayPreviewFromInput();
    });
    resetTransformBtn.addEventListener('click', () => {
        globalMergeSettings.rotation = 0;
        globalMergeSettings.flipX = 1;
        renderOverlayPreviewFromInput();
    });
    controlsWired = true;
}

/* Individual Editor helpers (unchanged from original code but included for completeness) */

const indBrightnessSlider = byId('indBrightnessSlider');
const indContrastSlider = byId('indContrastSlider');
const indSaturationSlider = byId('indSaturationSlider');
const indBrightnessValueSpan = byId('indBrightnessValue');
const indContrastValueSpan = byId('indContrastValue');
const indSaturationValueSpan = byId('indSaturationValue');
const indRotateBtn = byId('indRotateBtn');
const indFlipXBtn = byId('indFlipXBtn');
const indResetFiltersBtn = byId('indResetFiltersBtn');
const indResetTransformBtn = byId('indResetTransformBtn');
const indDoneBtn = byId('indDoneBtn');
const indClearBtn = byId('indClearBtn');

function openIndividualEditor(index, file) {
    if (file.name.toLowerCase().match(/\.(jpe?g|png|gif|bmp|webp|pdf)$/) === null) {
        postMsg.innerHTML = `<div class="error" style="margin-top:8px">Individual editing is only supported for Images and PDFs.</div>`;
        return;
    }
    currentEditingFile = file;
    globalEditorContainer.style.display = 'none';
    individualEditorContainer.style.display = 'flex';
    byId('currentFileName').textContent = file.name;
    overlayDrop.style.display = 'none'; // Hide dropzone while editing

    // Get current effective settings (global + individual overrides)
    const settings = getSettings(file);

    // Ensure there is an individual setting entry for this file name
    // This makes sure we are editing a key in individualFileSettings, defaulting to its current effective settings
    if (!individualFileSettings[file.name]) {
        individualFileSettings[file.name] = {
            rotation: settings.rotation,
            flipX: settings.flipX,
            brightness: settings.brightness,
            contrast: settings.contrast,
            saturation: settings.saturation,
        };
    }

    // Set initial slider values
    indBrightnessSlider.value = settings.brightness;
    indContrastSlider.value = settings.contrast;
    indSaturationSlider.value = settings.saturation;
    indBrightnessValueSpan.textContent = settings.brightness;
    indContrastValueSpan.textContent = settings.contrast;
    indSaturationValueSpan.textContent = settings.saturation;

    // Update the preview area to show only the selected file
    renderSingleFilePreview(file);

    // Wire up controls (or re-wire for the current file)
    wireIndividualControls(file);
}

function closeIndividualEditor() {
    individualEditorContainer.style.display = 'none';
    globalEditorContainer.style.display = 'flex';
    overlayDrop.style.display = 'block';
    currentEditingFile = null;
    renderOverlayPreviewFromInput(); // Re-render the full list with updated thumbnail
}

function renderSingleFilePreview(file) {
    overlayPreview.style.display = 'flex';
    overlayPreview.innerHTML = '';
    overlayCount.textContent = `Editing: ${file.name}`;

    const card = document.createElement('div');
    card.className='preview-card';
    card.style.width='300px';
    card.style.height='300px';
    card.style.cursor='default';
    card.style.margin='20px auto';
    card.draggable = false;

    const previewEl = document.createElement('div');
    previewEl.style.minHeight='200px';
    previewEl.style.maxHeight='200px';
    previewEl.style.display='flex';
    previewEl.style.alignItems='center';
    previewEl.style.justifyContent='center';
    previewEl.style.position='relative';
    
    const canvas = document.createElement('canvas');
    canvas.style.maxWidth='100%';
    canvas.style.maxHeight='100%';
    previewEl.appendChild(canvas);

    // Get current settings for the single file
    const settings = individualFileSettings[file.name] || getSettings(file);
    
    // The individual editor only supports Image/PDF files. 
    const isImageFile = file.name.toLowerCase().match(/\.(jpe?g|png|gif|bmp|webp)$/) || (file.type && file.type.startsWith('image/'));

    if (isImageFile) {
        applyImageEditsToCanvas(canvas, file, settings).catch(e => {
            console.error("Single File Preview Error:", e);
            previewEl.innerHTML = '<div class="muted">Preview Error</div>';
        });
    } else if (file.name.toLowerCase().endsWith('.pdf')) {
        // Render PDF preview (using logic from renderOverlayPreviewFromInput's PDF section)
        (async () => {
            try {
                const fbytes = await readAsArrayBuffer(file);
                const pdf = await pdfjsLib.getDocument({ data: fbytes }).promise;
                const page = await pdf.getPage(1);
                const { rotation, flipX } = settings;
                
                let isRotated = rotation % 180 !== 0; // 90 or 270 degrees
                
                // 1. Calculate PDF viewport with rotation applied
                const viewport = page.getViewport({ scale: 0.8, rotation: rotation });
                
                // 2. Adjust canvas size based on final rotated dimensions
                const ratio = Math.min(300 / viewport.width, 300 / viewport.height, 1);
                const scaled = page.getViewport({ scale: ratio, rotation: rotation });
                canvas.width = scaled.width;
                canvas.height = scaled.height;

                const ctx = canvas.getContext('2d');

                // 3. Apply flip transformation before rendering PDF page content
                ctx.save();
                if(flipX === -1) {
                    // For flip, translate to the center and flip the x-axis, then translate back
                    if (isRotated) {
                        // If rotated and flipped: need to flip around the new center
                        ctx.translate(canvas.width / 2, canvas.height / 2);
                        ctx.scale(-1, 1);
                        ctx.translate(-canvas.width / 2, -canvas.height / 2);
                    } else {
                        ctx.translate(canvas.width, 0);
                        ctx.scale(-1, 1);
                    }
                }
                
                // Render PDF page with the calculated rotated viewport
                await page.render({
                    canvasContext: ctx,
                    viewport: scaled
                }).promise;
                
                ctx.restore(); // Restore context state
            }catch(e){
                previewEl.innerHTML = '<div class="muted">Preview error</div>';
            }
        })();
    } else {
        previewEl.innerHTML = `<div class="muted">Preview not available for this type.</div>`;
    }

    const title = document.createElement('div');
    title.className='muted';
    title.style.marginTop='6px';
    title.textContent = `File: ${file.name}`;
    card.appendChild(previewEl);
    card.appendChild(title);
    overlayPreview.appendChild(card);
}

let individualControlsWired = false;
function wireIndividualControls(file) {
    const key = file.name;

    const updateSettingsAndRedraw = () => {
        const settings = individualFileSettings[key];
        settings.brightness = Number(indBrightnessSlider.value);
        settings.contrast = Number(indContrastSlider.value);
        settings.saturation = Number(indSaturationSlider.value);
        indBrightnessValueSpan.textContent = settings.brightness;
        indContrastValueSpan.textContent = settings.contrast;
        indSaturationValueSpan.textContent = settings.saturation;
        renderSingleFilePreview(file); // Redraw the single file preview
    };

    const handleResetFilters = () => {
        individualFileSettings[key].brightness = 0;
        individualFileSettings[key].contrast = 0;
        individualFileSettings[key].saturation = 0;
        indBrightnessSlider.value = 0;
        indContrastSlider.value = 0;
        indSaturationSlider.value = 0;
        updateSettingsAndRedraw();
    };

    const handleRotate = () => {
        let settings = individualFileSettings[key];
        settings.rotation = ((settings.rotation || 0) + 90) % 360;
        renderSingleFilePreview(file);
    };

    const handleFlipX = () => {
        let settings = individualFileSettings[key];
        settings.flipX = (settings.flipX || 1) * -1;
        renderSingleFilePreview(file);
    };

    const handleResetTransform = () => {
        individualFileSettings[key].rotation = 0;
        individualFileSettings[key].flipX = 1;
        renderSingleFilePreview(file);
    };
    
    const handleClearEdits = () => {
        delete individualFileSettings[key];
        closeIndividualEditor();
    };


    if (individualControlsWired) {
        // Re-wire/update listeners for the current file
        indBrightnessSlider.oninput = updateSettingsAndRedraw;
        indContrastSlider.oninput = updateSettingsAndRedraw;
        indSaturationSlider.oninput = updateSettingsAndRedraw;
        indResetFiltersBtn.onclick = handleResetFilters;
        indRotateBtn.onclick = handleRotate;
        indFlipXBtn.onclick = handleFlipX;
        indResetTransformBtn.onclick = handleResetTransform;
        indDoneBtn.onclick = closeIndividualEditor;
        indClearBtn.onclick = handleClearEdits;
        return;
    }
    
    indBrightnessSlider.addEventListener('input', updateSettingsAndRedraw);
    indContrastSlider.addEventListener('input', updateSettingsAndRedraw);
    indSaturationSlider.addEventListener('input', updateSettingsAndRedraw);
    indResetFiltersBtn.addEventListener('click', handleResetFilters);
    indRotateBtn.addEventListener('click', handleRotate);
    indFlipXBtn.addEventListener('click', handleFlipX);
    indResetTransformBtn.addEventListener('click', handleResetTransform);
    indDoneBtn.addEventListener('click', closeIndividualEditor);
    indClearBtn.addEventListener('click', handleClearEdits);

    individualControlsWired = true;
}

/* drag/drop reordering helper */
function reorderFiles(input, from, to) {
    const files = Array.from(input.files);
    const fileToMove = files.splice(from, 1)[0];
    files.splice(to, 0, fileToMove);
    
    // Also move the settings
    const fileSettings = individualFileSettings[fileToMove.name];
    
    // Create new DataTransfer object
    const dt = new DataTransfer();
    files.forEach(f => dt.items.add(f));
    input.files = dt.files;
    setListFromInput(activeSection);
}

/* remove file from overlay */
function overlayRemove(index){
    const input = byId(activeSection+'Files');
    const files = Array.from(input.files);
    const fileToRemove = files[index];

    // Remove file from individual settings if it exists
    if (fileToRemove && individualFileSettings[fileToRemove.name]) {
        delete individualFileSettings[fileToRemove.name];
    }
    
    const dt = new DataTransfer();
    files.forEach((f,i)=> {
        if(i!==index) dt.items.add(f);
    });
    input.files = dt.files;
    setListFromInput(activeSection);
    renderOverlayPreviewFromInput();
    overlayCount.textContent = (input.files.length || 0) + ' files';
}


/**
 * Renders the file list or the thumbnail preview area inside the overlay.
 * Uses the drag-reorderable list view for > 20 files.
 */
function renderOverlayPreviewFromInput(){
    const input = byId(activeSection+'Files');
    const files = Array.from(input.files || []);
    overlayPreview.innerHTML='';
    overlayCount.textContent = (files.length || 0) + ' files';
    
    if(!files.length){
        overlayPreview.innerHTML='<div class="muted" style="margin-top:10px">No files selected.</div>';
        return;
    }

    // Use a simple drag-reorderable list for large number of files (e.g., > 20)
    if(files.length > 20){
        const container = document.createElement('div');
        container.className='light-list';
        container.style.width='100%';
        files.forEach((f,i)=>{
            const row = document.createElement('div');
            row.className='list-row';
            row.draggable = true;
            row.dataset.index = i;
            
            const left = document.createElement('div');
            left.style.display='flex';
            left.style.alignItems='center';
            
            const handle = document.createElement('div');
            handle.className='drag-handle';
            handle.textContent='‚ò∞';
            left.appendChild(handle);

            const meta = document.createElement('div');
            meta.textContent = `${i+1}. ${f.name} (${formatFileSize(f.size)})`;
            meta.style.marginLeft='8px';
            left.appendChild(meta);

            const right = document.createElement('div');
            // New: Add Edit button for merge section
            if (activeSection === 'merge') {
                const editBtn = document.createElement('button');
                editBtn.textContent='Edit';
                editBtn.className='secondary';
                editBtn.style.marginRight='8px';
                editBtn.addEventListener('click', (e)=> { 
                    e.stopPropagation(); 
                    openIndividualEditor(i, f);
                });
                right.appendChild(editBtn);
            }
            
            const viewBtn = document.createElement('button');
            viewBtn.textContent='View';
            viewBtn.addEventListener('click', (e)=> { e.stopPropagation(); openFileInNewTab(f); });
            
            const delBtn = document.createElement('button');
            delBtn.className='secondary';
            delBtn.textContent='Delete';
            delBtn.addEventListener('click', (e)=> { e.stopPropagation(); overlayRemove(i); });
            
            right.appendChild(viewBtn);
            right.appendChild(delBtn);
            
            row.appendChild(left);
            row.appendChild(right);
            container.appendChild(row);

            // drag-drop reordering handlers within overlay list
            row.addEventListener('dragstart', ev=>{
                ev.dataTransfer.setData('text/plain', i);
                row.classList.add('dragging');
            });
            row.addEventListener('dragend', ()=> row.classList.remove('dragging'));
            row.addEventListener('dragover', ev=> ev.preventDefault());
            row.addEventListener('drop', ev=>{
                ev.preventDefault();
                const from = Number(ev.dataTransfer.getData('text/plain'));
                const to = Number(row.dataset.index);
                reorderFiles(input, from, to);
                renderOverlayPreviewFromInput();
            });
        });
        overlayPreview.appendChild(container);
        return;
    }

    // For moderate number of files, create cards with thumbnail/content preview
    for(let i=0;i<files.length;i++){
        const f = files[i];
        const settings = getSettings(f);

        const card = document.createElement('div');
        card.className='preview-card';
        card.draggable = true;
        card.dataset.index = i;
        card.style.color='#111';

        // NEW: Individual Edit Click Handler
        if (activeSection === 'merge') {
            card.addEventListener('click', ()=> openIndividualEditor(i, f)); // Click photo to edit
            card.style.cursor = 'pointer';
            
            // Highlight if individual edits exist or if global edits apply to this file type
            const hasIndividualEdit = individualFileSettings[f.name] && Object.values(individualFileSettings[f.name]).some(v => v !== 0 && v !== 1);
            const isImageOrPdf = f.name.toLowerCase().match(/\.(jpe?g|png|gif|bmp|webp|pdf)$/) || (f.type && (f.type.startsWith('image/') || f.type === 'application/pdf'));
            const hasGlobalEdit = isImageOrPdf && (globalMergeSettings.rotation !== 0 || globalMergeSettings.flipX !== 1 || globalMergeSettings.brightness !== 0 || globalMergeSettings.contrast !== 0 || globalMergeSettings.saturation !== 0);
            
            if (hasIndividualEdit || hasGlobalEdit) {
                 card.classList.add('individual-edit');
            }
        }
        
        // drag-drop reordering handlers on the cards
        card.addEventListener('dragstart', ev=>{ ev.dataTransfer.setData('text/plain', i); card.classList.add('dragging'); });
        card.addEventListener('dragend', ()=> card.classList.remove('dragging'));
        card.addEventListener('dragover', ev=> ev.preventDefault());
        card.addEventListener('drop', ev=>{
            ev.preventDefault();
            const from = Number(ev.dataTransfer.getData('text/plain'));
            const to = Number(card.dataset.index);
            reorderFiles(input, from, to);
            renderOverlayPreviewFromInput();
        });

        const previewEl = document.createElement('div');
        previewEl.style.minHeight='90px';
        previewEl.style.display='flex';
        previewEl.style.alignItems='center';
        previewEl.style.justifyContent='center';
        
        const isImageFile = f.name.toLowerCase().match(/\.(jpe?g|png|gif|bmp|webp)$/) || (f.type && f.type.startsWith('image/'));

        if(isImageFile){
            // Use Canvas for image preview to show edits
            const canvas = document.createElement('canvas');
            canvas.width=150; canvas.height=90;
            applyImageEditsToCanvas(canvas, f, settings).catch(e => {
                console.error("Preview Error:", e);
                previewEl.innerHTML = '<div class="muted">Preview Error</div>';
            });
            previewEl.appendChild(canvas);

        } else if (f.name.toLowerCase().endsWith('.pdf')){
            // PDF Preview (only page 1)
            const canvas = document.createElement('canvas');
            canvas.width=150; canvas.height=90;
            
            // Only render preview if less than 50 files for performance
            if (files.length < 50) {
                (async () => {
                    try {
                        const fbytes = await readAsArrayBuffer(f);
                        const pdf = await pdfjsLib.getDocument({ data: fbytes }).promise;
                        const page = await pdf.getPage(1);
                        const { rotation, flipX } = settings;
                        
                        let isRotated = rotation % 180 !== 0; // 90 or 270 degrees
                        
                        // 1. Calculate PDF viewport with rotation applied
                        const viewport = page.getViewport({ scale: 0.8, rotation: rotation });
                        
                        // 2. Adjust canvas size based on final rotated dimensions
                        const ratio = Math.min(150/viewport.width, 90/viewport.height, 1);
                        const scaled = page.getViewport({ scale: ratio, rotation: rotation });
                        canvas.width = scaled.width;
                        canvas.height = scaled.height;

                        const ctx = canvas.getContext('2d');

                        // 3. Apply flip transformation before rendering PDF page content
                        ctx.save();
                        if(flipX === -1) {
                            // For flip, translate to the center and flip the x-axis, then translate back
                            if (isRotated) {
                                // If rotated and flipped: need to flip around the new center
                                ctx.translate(canvas.width / 2, canvas.height / 2);
                                ctx.scale(-1, 1);
                                ctx.translate(-canvas.width / 2, -canvas.height / 2);
                            } else {
                                ctx.translate(canvas.width, 0);
                                ctx.scale(-1, 1);
                            }
                        }
                        
                        // Render PDF page with the calculated rotated viewport
                        await page.render({
                            canvasContext: ctx,
                            viewport: scaled
                        }).promise;
                        
                        ctx.restore(); // Restore context state
                    }catch(e){
                        previewEl.innerHTML = '<div class="muted">Preview error in main thread render logic';
                    }
                })();
            }

            previewEl.appendChild(canvas);
        } else {
            // Fallback: display file extension as a badge
            const ext = (f.name.split('.').pop() || '').toUpperCase();
            const icon = document.createElement('div');
            icon.innerHTML = `<div style="font-weight:700;font-size:18px">${escapeHtml(ext)}</div>`;
            previewEl.appendChild(icon);
        }

        card.appendChild(previewEl);

        // Added file size to the title line
        const title = document.createElement('div');
        title.className='muted';
        title.style.marginTop='6px';
        title.textContent = `${i+1}. ${f.name} (${formatFileSize(f.size)})`;
        card.appendChild(title);

        const actions = document.createElement('div');
        actions.className='preview-actions';
        
        const delBtn = document.createElement('button');
        delBtn.className='secondary';
        delBtn.textContent='Delete';
        delBtn.style.padding = '4px 8px';
        delBtn.addEventListener('click', (e)=> { e.stopPropagation(); overlayRemove(i); });
        actions.appendChild(delBtn);
        
        card.appendChild(actions);
        overlayPreview.appendChild(card);
    }
}


/* Open a file in a new tab using an object URL */
function openFileInNewTab(file){
    const url = URL.createObjectURL(file);
    window.open(url,'_blank');
    // revoke later to release memory (timeout keeps it open briefly)
    setTimeout(()=> URL.revokeObjectURL(url), 30000);
}

/* ---------- conversion helpers (utilities) ---------- */
/* Utility: read a File as ArrayBuffer (promisified FileReader) */
const readAsArrayBuffer = (file) => new Promise((res,rej)=>{
    const r=new FileReader(); 
    r.onload=()=>res(r.result); 
    r.onerror=rej; 
    r.readAsArrayBuffer(file); 
});


/* ========================================================= */
/* === HIGH-SPEED PARALLEL PROCESSING IMPLEMENTATION (NEW) === */
/* ========================================================= */

/**
 * Generates the Web Worker script logic as a string.
 * This script is responsible for the CPU-intensive tasks.
 */
function createWorkerScript() {
    // These functions must be self-contained in the worker script string.
    const workerFunctions = `
        const readAsArrayBuffer = (file) => new Promise((res,rej)=>{
            const r=new FileReader(); 
            r.onload=()=>res(r.result); 
            r.onerror=rej; 
            r.readAsArrayBuffer(file); 
        });

        // 1. Color filter logic - identical to main thread but faster in worker
        function applyColorFilter(canvas, brightness, contrast, saturation) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const b = brightness / 100 * 255;
            const c = (contrast + 100) / 100;
            const S = (saturation / 100) + 1;
            const L_R = 0.2126; const L_G = 0.7152; const L_B = 0.0722;

            for (let i = 0; i < data.length; i += 4) {
                let r = data[i], g = data[i + 1], b_val = data[i + 2];
                r = Math.max(0, Math.min(255, ((r + b - 128) * c) + 128));
                g = Math.max(0, Math.min(255, ((g + b - 128) * c) + 128));
                b_val = Math.max(0, Math.min(255, ((b_val + b - 128) * c) + 128));

                if (S !== 1) {
                    const avg = r * L_R + g * L_G + b_val * L_B;
                    r = avg * (1 - S) + r * S;
                    g = avg * (1 - S) + g * S;
                    b_val = avg * (1 - S) + b_val * S;
                }

                data[i] = Math.max(0, Math.min(255, r));
                data[i + 1] = Math.max(0, Math.min(255, g));
                data[i + 2] = Math.max(0, Math.min(255, b_val));
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // 2. Image editing logic - uses createImageBitmap for fast offscreen loading
        async function processImage(file, settings) {
            const { rotation, flipX, brightness, contrast, saturation } = settings;
            const buffer = await readAsArrayBuffer(file);
            const blob = new Blob([buffer], { type: file.type });
            
            // Use createImageBitmap for fast off-main-thread image loading
            const imgBitmap = await createImageBitmap(blob);
            
            const w_orig = imgBitmap.width;
            const h_orig = imgBitmap.height;
            const isRotated = (rotation % 180) !== 0;

            let w = w_orig;
            let h = h_orig;

            // Use OffscreenCanvas if available, otherwise fallback to standard Canvas (still off-main-thread)
            const canvas = self.OffscreenCanvas ? new OffscreenCanvas(1, 1) : document.createElement('canvas');
            
            // 1. Calculate Canvas Dimensions based on Rotation
            if(isRotated) {
                canvas.width = h;
                canvas.height = w;
            } else {
                canvas.width = w;
                canvas.height = h;
            }
            
            const ctx = canvas.getContext('2d');

            // 2. Apply Transformations
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(flipX, 1);
            ctx.rotate(rotation * Math.PI / 180);
            
            // 3. Draw the image (full resolution)
            let dx = 0, dy = 0, dw = w, dh = h;
            if (isRotated) {
                dx = -dh / 2; dy = -dw / 2; dw = dh; dh = dw; 
                ctx.drawImage(imgBitmap, dx, dy, dw, dh);
            } else {
                ctx.drawImage(imgBitmap, -dw / 2, -dh / 2, dw, dh);
            }
            ctx.restore();

            // 4. Apply Color Filters (CPU heavy part, now offloaded)
            if(brightness !== 0 || contrast !== 0 || saturation !== 0) {
                applyColorFilter(canvas, brightness, contrast, saturation);
            }
            
            // 5. Convert final canvas content to a PNG ArrayBuffer for easy PDF embedding
            const pngBlob = await new Promise((resolve, reject) => {
                // If OffscreenCanvas, use convertToBlob. If standard Canvas, use toBlob (fallback)
                if (canvas.convertToBlob) {
                    canvas.convertToBlob({ type: 'image/png' }).then(resolve).catch(reject);
                } else if (canvas.toBlob) {
                    canvas.toBlob(resolve, 'image/png');
                } else {
                    reject(new Error('Canvas to Blob not supported in this context.'));
                }
            });
            
            return await readAsArrayBuffer(pngBlob);
        }

        // Main worker message listener
        self.onmessage = async (e) => {
            const { file, settings, index, type } = e.data;
            try {
                let resultBuffer = null;
                
                if (type === 'image') {
                    resultBuffer = await processImage(file, settings);
                } else if (type === 'pdf') {
                    // For PDF, we just read the raw buffer. pdf-lib page copying must be on main thread.
                    resultBuffer = await readAsArrayBuffer(file);
                } else {
                     // For unsupported files, return an empty buffer to be skipped
                     postMessage({ index, status: 'unsupported' });
                     return;
                }

                // Send back the processed buffer and its index.
                // The transfer list [resultBuffer] ensures the data is MOVED, not copied, for maximum speed.
                postMessage({ index, status: 'success', buffer: resultBuffer, filename: file.name }, [resultBuffer]);

            } catch (error) {
                console.error("Worker error processing file " + file.name + ":", error);
                postMessage({ index, status: 'error', error: error.message, filename: file.name });
            }
        };
    `;
    return workerFunctions;
}

/**
 * Manages a pool of Web Workers to process files in parallel.
 * This is the core speed optimization.
 */
class ParallelFileProcessor {
    constructor(maxWorkers = 4) {
        // Limit workers based on system cores, max 4 for web standard
        this.maxWorkers = Math.min(navigator.hardwareConcurrency || 4, maxWorkers);
        this.workers = [];
        this.workerURL = URL.createObjectURL(new Blob([createWorkerScript()], { type: 'application/javascript' }));
        this.initWorkers();
    }

    initWorkers() {
        for (let i = 0; i < this.maxWorkers; i++) {
            this.workers.push({
                worker: new Worker(this.workerURL),
                busy: false,
                id: i
            });
        }
    }

    terminate() {
        this.workers.forEach(w => w.worker.terminate());
        URL.revokeObjectURL(this.workerURL);
    }

    async process(files, getSettingsFn, onProgress) {
        const queue = files.map((file, index) => ({ file, index, settings: getSettingsFn(file) }));
        const results = new Array(files.length);
        let processedCount = 0;

        // Function to find an idle worker or wait for one to become free
        const getWorker = () => new Promise(resolve => {
            const check = () => {
                const idleWorker = this.workers.find(w => !w.busy);
                if (idleWorker) {
                    idleWorker.busy = true;
                    resolve(idleWorker);
                } else {
                    // Wait for a worker to finish a task
                    setTimeout(check, 10); 
                }
            };
            check();
        });

        const runTask = async (task) => {
            const workerInfo = await getWorker();
            const { file, settings, index } = task;
            
            const fileType = file.name.toLowerCase().endsWith('.pdf') ? 'pdf' : (file.type.startsWith('image/') ? 'image' : 'other');

            return new Promise((resolve, reject) => {
                workerInfo.worker.onmessage = (e) => {
                    workerInfo.busy = false; // Worker is now free
                    const data = e.data;
                    if (data.status === 'success') {
                        results[data.index] = { type: fileType, buffer: data.buffer, filename: data.filename, index: data.index };
                    } else if (data.status === 'unsupported') {
                        results[data.index] = { type: 'unsupported', filename: data.filename, index: data.index };
                    } else {
                        // Handle error case
                        console.error('Worker error for file:', data.filename, data.error);
                        results[data.index] = { type: 'error', filename: data.filename, index: data.index, error: data.error };
                    }
                    processedCount++;
                    onProgress(processedCount);
                    resolve();
                };

                workerInfo.worker.onerror = (error) => {
                    workerInfo.busy = false; // Worker is now free
                    console.error('Worker runtime error:', error);
                    results[index] = { type: 'error', filename: file.name, index: index, error: 'Worker runtime error' };
                    processedCount++;
                    onProgress(processedCount);
                    resolve();
                };

                // Send the file and settings to the worker (transferring the file object itself)
                workerInfo.worker.postMessage({ file, settings, index, type: fileType });
            });
        };

        const taskPromises = queue.map(task => runTask(task));
        await Promise.all(taskPromises);

        return results.sort((a,b) => a.index - b.index); // Return results in original order
    }
}


/* ---------- conversion implementations (UPDATED) ---------- */

/* MERGE ANY FILE (PDFs and Images) (client-side using pdf-lib with parallelism) */
async function doMergeAnyFileToPdf(){
    const input = byId('mergeFiles');
    if(!input.files.length) throw new Error('No files selected');
    
    const startTime = performance.now();
    
    const files = Array.from(input.files);
    
    // --- 1. Parallel Pre-Processing ---
    postMsg.innerHTML = `<div class="notice">Starting parallel file pre-processing... (0/${files.length})</div>`;
    const processor = new ParallelFileProcessor(4); // Use up to 4 concurrent workers
    
    const processedResults = await processor.process(files, getSettings, (count) => {
        postMsg.innerHTML = `<div class="notice">Processing files in parallel... (${count}/${files.length})</div>`;
    });
    
    processor.terminate(); // Shut down workers to free memory
    postMsg.innerHTML = `<div class="notice success">Pre-processing complete. Assembling final PDF...</div>`;

    // --- 2. Sequential PDF Assembly (Main Thread) ---
    const pdfDoc = await PDFLib.PDFDocument.create();
    const [pageW, pageH] = [595.28, 841.89];
    const margin = 50;
    const maxW = pageW - margin*2;
    const maxH = pageH - margin*2;
    const unsupportedFiles = [];
    
    for(const result of processedResults){
        if (result.type === 'image') {
            // Processed image buffer (PNG) received from the worker
            const embedded = await pdfDoc.embedPng(result.buffer);
            const page = pdfDoc.addPage([pageW, pageH]);
            
            // Calculate scale to fit within page margins (same logic as before)
            const imgDims = embedded.scale(1); 
            const scale = Math.min(maxW / imgDims.width, maxH / imgDims.height, 1);
            const drawW = imgDims.width * scale;
            const drawH = imgDims.height * scale;
            const x = (pageW - drawW)/2;
            const y = (pageH - drawH)/2;
            
            page.drawImage(embedded, { x, y, width: drawW, height: drawH });

        } else if (result.type === 'pdf') {
            // Raw PDF buffer received from the worker
            try {
                const embeddedPdf = await PDFLib.PDFDocument.load(result.buffer);
                const pages = await pdfDoc.copyPages(embeddedPdf, embeddedPdf.getPageIndices());
                pages.forEach(p => pdfDoc.addPage(p));
            } catch (e) {
                console.error("Failed to copy PDF pages for file:", result.filename, e);
                unsupportedFiles.push(result.filename + ' (PDF copy failed)');
            }
        } else {
            unsupportedFiles.push(result.filename);
        }
    }

    if (unsupportedFiles.length) {
        // Add a final page listing skipped files
        const page = pdfDoc.addPage([pageW, pageH]);
        const text = `The following files were skipped: ${unsupportedFiles.join(', ')}`;
        page.drawText(text, { x: 50, y: pageH - 50, size: 12 });
    }
    
    // --- 3. Finalization ---
    const pdfBytes = await pdfDoc.save();
    
    // Use 'All-in-one-merge' for the default filename
   
/*-============Auto File name  ===========*/
    const filename = 'All-in-one-merge.pdf';
    const mime = 'application/pdf';
    
    const endTime = performance.now();
    const duration = ((endTime - startTime) / 1000).toFixed(2);
    
    postMsg.innerHTML = `<div class="notice success">Conversion finished in ${duration} seconds.</div>`;
    
    return { blob: new Blob([pdfBytes], {type: mime}), filename, mime };
}

/* DOCX -> PDF (client-side approximation) */
async function doDocxToPdf(){
    const inEl = byId('docx2pdfFiles');
    if(!inEl || !inEl.files[0]) throw new Error('Pick a .docx file');
    const ab = await readAsArrayBuffer(inEl.files[0]);
    const result = await mammoth.convertToHtml({ arrayBuffer: ab });
    const tmp = document.createElement('div');
    tmp.innerHTML = result.value;
    const textBlocks = Array.from(tmp.querySelectorAll('p, h1, h2, h3, h4, h5, h6')).map(el=> ({ text: el.textContent, margin:[0,4,0,4] }));
    
    const docDef = { 
        content: textBlocks, 
        defaultStyle:{ fontSize:11 } 
    };
    
    return new Promise((res,rej)=> pdfMake.createPdf(docDef).getBlob(blob => {
        const filename = (inEl.files[0].name.replace(/\.docx?$/i, '') || 'document') + '.pdf';
        const mime = 'application/pdf';
        res({ blob, filename, mime });
    }, rej));
}


/* PDF -> DOCX (client-side approximation: text extraction) */
async function doPdfToDocx(){
    const inEl = byId('pdf2docxFiles');
    if(!inEl || !inEl.files[0]) throw new Error('Pick a .pdf file');
    
    // Load docx library dynamically if it isn't defined (fallback/ensure load)
    if (!window.docx) {
        await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js";
            script.onload = () => {
                if (window.docx) resolve();
                else reject(new Error("DOCX script failed to define window.docx."));
            };
            script.onerror = () => reject(new Error("Failed to load DOCX library from CDN."));
            document.head.appendChild(script);
        });
    }

    const { Document, Paragraph, Packer } = window.docx;
    const file = inEl.files[0];
    const fbytes = await file.arrayBuffer();
    
    const pdf = await pdfjsLib.getDocument({ data: fbytes }).promise;
    const paragraphs = [];

    for (let p = 1; p <= pdf.numPages; p++) {
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        const text = content.items.map(i => i.str || '').join(' ');
        paragraphs.push(new Paragraph(`‚Äî Page ${p} ‚Äî`));
        paragraphs.push(new Paragraph(text.trim()));
    }
    
    const doc = new Document({
        sections: [{ children: paragraphs }]
    });

    const blob = await Packer.toBlob(doc);
    const filename = (file.name.replace(/\.pdf$/i, '') || 'document') + '.docx';
    const mime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    
    return { blob, filename, mime };
}


/* XLSX -> PDF (client-side approximation) */
async function doXlsxToPdf(){
    const inEl = byId('xls2pdfFiles');
    if(!inEl || !inEl.files[0]) throw new Error('Pick a .xlsx file');
    const ab = await readAsArrayBuffer(inEl.files[0]);
    
    const wb = XLSX.read(ab, {type:'array'});
    
    // Simple text-based conversion: read all sheets, convert to text blocks
    const content = [];
    wb.SheetNames.forEach(sheetName => {
        const ws = wb.Sheets[sheetName];
        content.push({ text: `--- Sheet: ${sheetName} ---`, margin: [0, 10, 0, 5], bold: true, fontSize: 14 });
        const data = XLSX.utils.sheet_to_json(ws, {header:1});
        
        data.forEach(row => {
            if (row.length > 0) {
                content.push({ text: row.join(' | '), margin: [0, 2, 0, 2], fontSize: 9, lineHeight: 1.2 });
            }
        });
    });

    const docDef = { 
        content: content, 
        defaultStyle:{ fontSize:10 } 
    };

    return new Promise((res,rej)=> pdfMake.createPdf(docDef).getBlob(blob => {
        const filename = (inEl.files[0].name.replace(/\.xlsx?$/i, '') || 'spreadsheet') + '.pdf';
        const mime = 'application/pdf';
        res({ blob, filename, mime });
    }, rej));
}


/* PDF -> XLSX (text extraction per page) */
async function doPdfToXlsx(){
    const inEl = byId('pdf2xlsFiles');
    if(!inEl || !inEl.files[0]) throw new Error('Pick a .pdf file');
    const ab = await readAsArrayBuffer(inEl.files[0]);
    
    const pdf = await pdfjsLib.getDocument({data:ab}).promise;
    const rows=[];

    for(let p=1;p<=pdf.numPages;p++){
        const page = await pdf.getPage(p);
        const content = await page.getTextContent();
        // Concatenate all text on the page into a single string for the cell
        const line = content.items.map(i=>i.str).join(' ');
        rows.push([`Page ${p}`, line]);
    }

    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet([['Page','Content'], ...rows]);
    XLSX.utils.book_append_sheet(wb, ws, 'Extracted');

    const out = XLSX.write(wb, { type:'array', bookType:'xlsx' });

    return { 
        blob: new Blob([out],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}),
        filename: (inEl.files[0].name.replace(/\.pdf$/i,'')||'pdf') + '.xlsx',
        mime:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    };
}


/* DOCX -> XLSX (paragraph extraction) */
async function doDocxToXlsx(){
    const inEl = byId('docx2xlsFiles');
    if(!inEl || !inEl.files[0]) throw new Error('Pick a .docx file');
    const ab = await readAsArrayBuffer(inEl.files[0]);
    
    // Extract raw text from the DOCX file
    const result = await mammoth.extractRawText({ arrayBuffer: ab });
    const lines = result.value.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
    
    // Convert lines into a column in Excel
    const data = [['Paragraph']].concat(lines.map(s=>[s]));
    
    const wb = XLSX.utils.book_new();
    const ws = XLSX.utils.aoa_to_sheet(data);
    XLSX.utils.book_append_sheet(wb, ws, 'Extracted');

    const out = XLSX.write(wb, { type:'array', bookType:'xlsx' });
    
    return {
        blob: new Blob([out],{type:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'}),
        filename: (inEl.files[0].name.replace(/\.docx?$/i,'')||'word') + '.xlsx',
        mime:'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    };
}


/* XLSX -> DOCX (table representation) */
async function doXlsxToDocx(){
    const inEl = byId('xls2docxFiles');
    if(!inEl || !inEl.files[0]) throw new Error('Pick a .xlsx file');
    
    // Load docx library dynamically if it isn't defined (fallback/ensure load)
    if (!window.docx) {
        await new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.js";
            script.onload = () => {
                if (window.docx) resolve();
                else reject(new Error("DOCX script failed to define window.docx."));
            };
            script.onerror = () => reject(new Error("Failed to load DOCX library from CDN."));
            document.head.appendChild(script);
        });
    }

    const { Document, Paragraph, Table, TableRow, TableCell, TextRun, Packer } = window.docx;
    const ab = await readAsArrayBuffer(inEl.files[0]);
    const wb = XLSX.read(ab, {type:'array'});
    
    const children = [];

    wb.SheetNames.forEach(sheetName => {
        children.push(new Paragraph({ children: [ new TextRun({ text: `Sheet: ${sheetName}`, bold: true, size: 36 }) ] }));
        
        const ws = wb.Sheets[sheetName];
        const jsonData = XLSX.utils.sheet_to_json(ws, {header:1, defval:""});

        // Convert data array to docx Table object
        const table = new Table({
            rows: jsonData.map(row => new TableRow({
                children: row.map(cellData => new TableCell({
                    children: [new Paragraph(String(cellData))],
                    // Simple light border style
                    borders: {
                        top: { style: 'single', size: 6, color: 'auto' },
                        bottom: { style: 'single', size: 6, color: 'auto' },
                        left: { style: 'single', size: 6, color: 'auto' },
                        right: { style: 'single', size: 6, color: 'auto' },
                    },
                    shading: {
                        fill: (jsonData[0] === row) ? "D3D3D3" : "FFFFFF", // Header row shading
                        type: "clear",
                        color: "auto",
                    }
                }))
            }))
        });
        children.push(table);
        children.push(new Paragraph('')); // Add a blank line after the table
    });

    const doc = new Document({ sections: [{ children }] });
    const blob = await Packer.toBlob(doc);
    const filename = (inEl.files[0].name.replace(/\.xlsx?$/i, '') || 'spreadsheet') + '.docx';
    const mime = 'application/vnd.openxmlformats-officedocument.wordprocessingml.document';
    
    return { blob, filename, mime };
}


/* ---------- main submission/routing logic (MODIFIED) ---------- */
const converterFns = {
    merge: doMergeAnyFileToPdf,
    pdf2docx: doPdfToDocx,
    docx2pdf: doDocxToPdf,
    xls2pdf: doXlsxToPdf,
    pdf2xls: doPdfToXlsx,
    docx2xls: doDocxToXlsx,
    xls2docx: doXlsxToDocx,
};

submitBtn.addEventListener('click', async()=>{
    if(!activeSection || !converterFns[activeSection]) return;
    const input = byId(activeSection+'Files');
    if(!input.files.length){
        postMsg.innerHTML = '<div class="error" style="margin-top:8px">Please select files first.</div>';
        return;
    }

    submitBtn.disabled=true;
    submitBtn.textContent='Working...';
    postMsg.innerHTML = '<div class="notice">Starting conversion. Please wait...</div>';

    try{
        const result = await converterFns[activeSection]();
        lastResult = result;
        
        // --- MODIFIED: Added dynamic file renaming UI ---
        const ext = '.' + (result.filename.split('.').pop() || 'file');
        const baseName = result.filename.replace(new RegExp(ext + '$'), '');
        
        postMsg.innerHTML = `
            <div class="success" style="margin-top:8px; display:flex; flex-direction:column; gap:8px;">
                <span>‚úÖ Conversion Successful! Edit the filename below:</span>
                <div style="display:flex; align-items:center; gap:5px;">
                    <label for="outputFileName" style="font-weight:700;">File Name:</label>
                    <input type="text" id="outputFileName" value="${baseName}" style="flex-grow:1; padding:6px; border-radius:6px; border:1px solid #ccc; color:#111; max-width:300px;">
                    <span style="font-weight:700;">${ext}</span>
                </div>
            </div>
        `;
        const fileNameInput = byId('outputFileName');
        const getFinalFilename = () => fileNameInput.value.trim() + ext;
        // --- END MODIFIED BLOCK ---
        
        downloadBtn.style.display='inline-block';
        downloadBtn.onclick = ()=> {
             const finalName = getFinalFilename();
             if(finalName.length <= ext.length) {
                 alert('Please enter a valid filename.');
                 return;
             }
             saveBlob(result.blob, finalName);
        };
        
        closeBtn.textContent = 'Done';
        closeBtn.onclick = closeFullscreen; // Hide overlay when done

        // Enable print button if result is a PDF
        if (result.mime === 'application/pdf'){
            printBtn.style.display='inline-block';
            printBtn.onclick = ()=> {
                // For printing, we still print the blob URL, as the dialog will handle the name locally.
                const url = URL.createObjectURL(result.blob);
                const w = window.open(url,'_blank');
                // small delay to allow new tab to load the PDF then call print
                setTimeout(()=> w.print(),700);
                setTimeout(()=> URL.revokeObjectURL(url),30000);
            };
        } else {
            printBtn.style.display='none';
            printBtn.onclick = null;
        }

    }catch(err){
        console.error(err);
        postMsg.innerHTML = `<div class="error" style="margin-top:8px">Error: ${escapeHtml(err.message || String(err))}</div>`;
    } finally{
        submitBtn.disabled=false;
        submitBtn.textContent='Submit';
    }
});

/* ---------- UI: background toggle button ---------- */
const toggleBtn = document.getElementById('toggleBgBtn');
const body = document.body;
let bgVisible = true; // starts with image shown

toggleBtn.addEventListener('click', () => {
    if (bgVisible) {
        // switch to gradient (remove image)
        body.classList.remove('bg-image');
        bgVisible = false;
        toggleBtn.textContent = "üåÖ Show Background";
    } else {
        // set image background class
        body.classList.add('bg-image');
        bgVisible = true;
        toggleBtn.textContent = "üåÖ Hide Background";
    }
});

/* ---------- helpers ---------- */
/* saveBlob: save a Blob to user's disk using FileSaver (or fallback anchor) */
function saveBlob(blob, filename){
    try{
        saveAs(blob, filename); // FileSaver library
    }catch(e){
        // fallback: create anchor element and trigger download
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
    }
}
  </script>
</body>
</html>

